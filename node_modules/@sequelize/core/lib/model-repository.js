"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var model_repository_exports = {};
__export(model_repository_exports, {
  ModelRepository: () => ModelRepository,
  getModelRepository: () => getModelRepository
});
module.exports = __toCommonJS(model_repository_exports);
var import_utils = require("@sequelize/utils");
var import_hooks = require("./hooks.js");
var import_model_internals = require("./model-internals.js");
var import_operators = require("./operators.js");
var import_check = require("./utils/check.js");
class ModelRepository {
  #modelDefinition;
  constructor(modelDefinition) {
    this.#modelDefinition = modelDefinition;
  }
  get #sequelize() {
    return this.#modelDefinition.sequelize;
  }
  get #queryInterface() {
    return this.#sequelize.queryInterface;
  }
  async _UNSTABLE_destroy(instanceOrInstances, options = import_utils.EMPTY_OBJECT) {
    const { ...optionsClone } = options;
    (0, import_model_internals.assertHasPrimaryKey)(this.#modelDefinition);
    (0, import_model_internals.setTransactionFromCls)(optionsClone, this.#sequelize);
    const instances = Array.isArray(instanceOrInstances) ? [...instanceOrInstances] : [instanceOrInstances];
    if (instances.length === 0) {
      return 0;
    }
    if ((0, import_check.isDevEnv)()) {
      (0, import_utils.freezeDescendants)((0, import_utils.cloneDeepPlainValues)(optionsClone, true));
    }
    if ((0, import_hooks.mayRunHook)("beforeDestroyMany", optionsClone.noHooks)) {
      await this.#modelDefinition.hooks.runAsync("beforeDestroyMany", instances, optionsClone);
      if (instances.length === 0) {
        return 0;
      }
    }
    Object.freeze(optionsClone);
    Object.freeze(instances);
    const isSoftDelete = !optionsClone.hardDelete && this.#modelDefinition.isParanoid();
    if (isSoftDelete) {
      throw new Error("ModelRepository#destroy does not support paranoid deletion yet.");
    }
    const primaryKeys = this.#modelDefinition.primaryKeysAttributeNames;
    let where;
    if (instances.length === 1) {
      where = (0, import_model_internals.getModelPkWhere)(instances[0], true);
    } else if (primaryKeys.size === 1 && !this.#modelDefinition.versionAttributeName) {
      const primaryKey = primaryKeys.values().next().value;
      const values = instances.map((instance) => (0, import_model_internals.getPrimaryKeyValueOrThrow)(instance, primaryKey));
      where = { [primaryKey]: values };
    } else {
      where = {
        // Ideally, we'd use tuple comparison here, but that's not supported by Sequelize yet.
        // It would look like this:
        // WHERE (id1, id2) IN ((1, 2), (3, 4))
        [import_operators.Op.or]: instances.map((instance) => (0, import_model_internals.getModelPkWhere)(instance, true))
      };
    }
    const bulkDeleteOptions = {
      ...optionsClone,
      limit: null,
      where
    };
    delete bulkDeleteOptions.hardDelete;
    delete bulkDeleteOptions.noHooks;
    const result = await this.#queryInterface.bulkDelete(this.#modelDefinition, bulkDeleteOptions);
    if ((0, import_hooks.mayRunHook)("afterDestroyMany", optionsClone.noHooks)) {
      await this.#modelDefinition.hooks.runAsync(
        "afterDestroyMany",
        instances,
        optionsClone,
        result
      );
    }
    return result;
  }
  // async save(instances: M[] | M): Promise<void> {}
  // async updateOne(instance: M, values: object, options: unknown): Promise<M> {}
  // async updateMany(data: Array<{ instance: M, values: object }>, options: unknown): Promise<M> {}
  // async updateMany(data: Array<{ where: object, values: object }>, options: unknown): Promise<M> {}
  // async restore(instances: M[] | M, options: unknown): Promise<number> {}
  // async bulkUpdate(options: unknown): Promise<M> {}
  // async bulkDestroy(options: unknown): Promise<M> {}
  // async bulkRestore(options: unknown): Promise<M> {}
}
const modelRepositories = /* @__PURE__ */ new WeakMap();
function getModelRepository(model) {
  let internals = modelRepositories.get(model);
  if (internals) {
    return internals;
  }
  internals = new ModelRepository(model);
  return internals;
}
//# sourceMappingURL=model-repository.js.map
